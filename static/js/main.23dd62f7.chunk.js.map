{"version":3,"sources":["utils/stateManagement.tsx","utils/dataSetHelpers.tsx","components/UploadArea.tsx","utils/ArrayBuffer-StringHelper.tsx","utils/parseData.tsx","utils/colorGeneration.tsx","components/BarChart.tsx","components/Dashboard.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["INSTANCE_DATA","DISCONNECTED","MY_CHARACTER_NAME","ARENA_INSTANCE_IDS","PLAYER_KEYS","filterRawData","data","filteredData","filter","match","includes","instanceID","playerName","hasOwnProperty","modifiedData","forEach","moddedMatch","enteredTime","instanceName","enemyTeamComp","myTeamComp","bracket","myTeam","enemyTeam","win","moddedMatchData","goldTeam","purpleTeam","winningFaction","myTeamNames","Object","keys","enemyTeamNames","myTeamPlayerCount","length","enemyTeamPlayerCount","Math","max","arenaBracket","i","push","fillNameArraysWithBlanks","myModdedTeam","enemyModdedTeam","name","idx","getModdedTeamsAndTeamComps","sort","getModdedArenaData","assign","teamObj","moddedTeamObj","compArr","playerDCed","class","fillTeamCompObject","obj","key","matchCount","wins","Number","UploadArea","lcHandler","lcVal","useState","text","setText","onDrop","useCallback","acceptedFiles","file","reader","FileReader","onabort","onerror","onload","buf","binaryStr","result","state","window","localStorage","getItem","parsedState","JSON","parse","mergedState","filteredState","Map","map","item","values","setItem","stringify","mergeState","start","lastIndexOf","newStr","slice","enumRegexp","RegExp","instanceDataArray","replaceAll","split","parsedData","el","e","parseData","TextDecoder","decode","Uint8Array","readAsArrayBuffer","useDropzone","getRootProps","getInputProps","className","calculatePoint","index","intervalSize","colorRangeInfo","colorStart","colorEnd","useEndAsStart","BarChart","dataset","totalMatchNumber","labelArr","dataArr","winsArr","colorArray","labels","datasets","label","backgroundColor","borderColor","borderWidth","hoverOffset","datasetKeys","getOwnPropertyNames","sortableEntries","teamComp","a","b","entry","dataLength","colorScale","targetArray","colorPoint","generateChartColors","interpolateTurbo","chartTitle","options","indexAxis","responsive","scales","y","ticks","color","font","size","family","stepSize","beginAtZero","plugins","tooltip","callbacks","afterLabel","dataIndex","winrate","toFixed","legend","display","Dashboard","props","matchData","setMatchData","localStorageChanged","setLocalStorageChanged","chartDataset","setChartDataset","useEffect","setReactState","currentState","localStorageToState","hasDCedPlayers","enemyTeamCompString","reduce","concat","createBasicChartDataset","onClick","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.23dd62f7.chunk.js","sourcesContent":["import React from \"react\";\nimport { ModdedArenaMatch } from \"../Types/ArenaTypes\";\n\nexport const INSTANCE_DATA = \"instanceData\";\n\nexport function mergeState(filteredData: ModdedArenaMatch[]): void {\n  const filterKey = \"enteredTime\";\n  const state = window.localStorage.getItem(INSTANCE_DATA);\n\n  if (!state) {\n    localStorage.setItem(INSTANCE_DATA, JSON.stringify(filteredData));\n    return;\n  }\n  const parsedState = JSON.parse(state);\n  const mergedState = [...parsedState, ...filteredData];\n\n  const filteredState = [\n    ...new Map(mergedState.map((item) => [item[filterKey], item])).values(),\n  ];\n\n  localStorage.setItem(INSTANCE_DATA, JSON.stringify(filteredState));\n}\n\nexport function localStorageToState(\n  setReactState: React.Dispatch<React.SetStateAction<ModdedArenaMatch[]>>\n): void {\n  const currentState = window.localStorage.getItem(INSTANCE_DATA);\n  currentState && setReactState(JSON.parse(currentState));\n}\n","import {\n  ArenaMatch,\n  ModdedArenaTeam,\n  arenaPlayerKeys,\n  ModdedArenaMatch,\n  ArenaTeam,\n  TeamCompDataset,\n} from \"../Types/ArenaTypes\";\n\nconst DISCONNECTED = \"!disconnected\";\nconst MY_CHARACTER_NAME: string = \"Sl√≠t\";\nconst MY_TEAMMATE_NAME: string = \"Induator\";\nconst ARENA_INSTANCE_IDS: number[] = [572, 562, 559]; // \"Ruins of Lordaeron\", \"Blade's Edge Arena\", \"Nagrand Arena\"\nconst PLAYER_KEYS: arenaPlayerKeys[] = [\n  \"player1\",\n  \"player2\",\n  \"player3\",\n  \"player4\",\n  \"player5\",\n];\n\nexport function filterRawData(data: ArenaMatch[]): ModdedArenaMatch[] {\n  const filteredData = data.filter(\n    (match) =>\n      ARENA_INSTANCE_IDS.includes(match.instanceID) &&\n      match.playerName === MY_CHARACTER_NAME &&\n      match.hasOwnProperty(\"purpleTeam\") &&\n      match.hasOwnProperty(\"goldTeam\")\n  );\n  const modifiedData: ModdedArenaMatch[] = [];\n  filteredData.forEach((match) => {\n    const moddedMatch: ModdedArenaMatch = {\n      enteredTime: match.enteredTime,\n      instanceID: match.instanceID,\n      instanceName: match.instanceName,\n      playerName: match.playerName,\n      enemyTeamComp: [],\n      myTeamComp: [],\n      bracket: 0,\n      myTeam: {},\n      enemyTeam: {},\n      win: false,\n    };\n\n    const moddedMatchData = getModdedArenaData(match);\n    Object.assign(moddedMatch, moddedMatchData);\n    modifiedData.push(moddedMatch);\n  });\n\n  return modifiedData;\n}\n\nfunction getModdedArenaData(match: ArenaMatch): any {\n  let myTeam: ArenaTeam, enemyTeam: ArenaTeam, win: boolean;\n  if (match.goldTeam.hasOwnProperty(MY_CHARACTER_NAME)) {\n    myTeam = match.goldTeam;\n    enemyTeam = match.purpleTeam;\n    win = !!match.winningFaction; //WIN\n  } else {\n    myTeam = match.purpleTeam;\n    enemyTeam = match.goldTeam;\n    win = !match.winningFaction; //WIN\n  }\n\n  const myTeamNames: (string | null)[] = Object.keys(myTeam);\n  const enemyTeamNames: (string | null)[] = Object.keys(enemyTeam);\n  const myTeamPlayerCount = myTeamNames.length;\n  const enemyTeamPlayerCount = enemyTeamNames.length;\n  const bracket = Math.max(myTeamPlayerCount, enemyTeamPlayerCount); // BRACKET\n  fillNameArraysWithBlanks(myTeamNames, enemyTeamNames, bracket);\n\n  // modded arena team\n  let myModdedTeam: ModdedArenaTeam = {};\n  let myTeamComp: string[] = [];\n  let enemyModdedTeam: ModdedArenaTeam = {};\n  let enemyTeamComp: string[] = [];\n  myTeamNames.forEach((name, idx) =>\n    getModdedTeamsAndTeamComps(name, idx, myTeam, myModdedTeam, myTeamComp)\n  );\n  enemyTeamNames.forEach((name, idx) =>\n    getModdedTeamsAndTeamComps(\n      name,\n      idx,\n      enemyTeam,\n      enemyModdedTeam,\n      enemyTeamComp\n    )\n  );\n  return {\n    bracket,\n    win,\n    myTeam: myModdedTeam,\n    myTeamComp: myTeamComp.sort(),\n    enemyTeam: enemyModdedTeam,\n    enemyTeamComp: enemyTeamComp.sort(),\n  };\n}\n\nfunction getModdedTeamsAndTeamComps(\n  name: string | null,\n  idx: number,\n  teamObj: ArenaTeam,\n  moddedTeamObj: ModdedArenaTeam,\n  compArr: string[]\n) {\n  const playerDCed = name === null;\n  moddedTeamObj[PLAYER_KEYS[idx]] = playerDCed\n    ? null\n    : {\n        name: name,\n        ...teamObj[name],\n      };\n  compArr.push(playerDCed ? DISCONNECTED : teamObj[name].class);\n}\n\nfunction fillNameArraysWithBlanks(\n  myTeamNames: (string | null)[],\n  enemyTeamNames: (string | null)[],\n  arenaBracket: number\n): void {\n  if (myTeamNames.length < arenaBracket) {\n    for (let i = 0; i < arenaBracket - myTeamNames.length; i++) {\n      myTeamNames.push(null);\n    }\n  }\n  if (enemyTeamNames.length < arenaBracket) {\n    for (let i = 0; i < arenaBracket - enemyTeamNames.length; i++) {\n      enemyTeamNames.push(null);\n    }\n  }\n}\n\nexport function createBasicChartDataset(\n  data: ModdedArenaMatch[]\n): TeamCompDataset {\n  const dataset: TeamCompDataset = {};\n  data.forEach((match) => {\n    const hasDCedPlayers =\n      match.enemyTeamComp.includes(DISCONNECTED) ||\n      match.myTeamComp.includes(DISCONNECTED);\n    const enemyTeamCompString = teamcompArrToString(match.enemyTeamComp);\n    if (hasDCedPlayers) {\n      fillTeamCompObject(dataset, \"DC\", match);\n    } else {\n      fillTeamCompObject(dataset, enemyTeamCompString, match);\n    }\n  });\n\n  return dataset;\n}\n\nfunction fillTeamCompObject(\n  obj: TeamCompDataset,\n  key: string,\n  match: ModdedArenaMatch\n): void {\n  if (obj[key]) {\n    obj[key].matchCount += 1;\n    match.win && obj[key].wins++;\n  } else {\n    obj[key] = { matchCount: 1, wins: Number(match.win) };\n  }\n}\n\nfunction teamcompArrToString(arr: string[]): string {\n  return arr.reduce((a, b) => a.concat(\" \\\\ \", b));\n}\n","import React, { useCallback, useState } from \"react\";\nimport { parseData } from \"../utils/parseData\";\nimport { arrayBufferToString } from \"../utils/ArrayBuffer-StringHelper\";\nimport { useDropzone } from \"react-dropzone\";\nimport { mergeState } from \"../utils/stateManagement\";\nimport { filterRawData } from \"../utils/dataSetHelpers\";\n\nexport type landingProps = {\n  lcHandler: React.Dispatch<React.SetStateAction<boolean>>;\n  lcVal: boolean;\n};\n\nconst UploadArea: React.FC<landingProps> = ({ lcHandler, lcVal }) => {\n  const [text, setText] = useState(\"Upload file here\");\n\n  const onDrop = useCallback(\n    (acceptedFiles) => {\n      acceptedFiles.forEach((file: any) => {\n        //TBD\n        const reader = new FileReader();\n\n        reader.onabort = () => setText(\"File reading was aborted\");\n        reader.onerror = () => setText(\"File reading failed\");\n        reader.onload = () => {\n          const binaryStr = reader.result;\n          const parsedData = parseData(arrayBufferToString(binaryStr));\n          const filteredData = filterRawData(parsedData);\n          mergeState(filteredData);\n          lcHandler(!lcVal);\n          setText(\"File successfully parsed\");\n        };\n        reader.readAsArrayBuffer(file);\n      });\n    },\n    [lcHandler, lcVal]\n  );\n  const { getRootProps, getInputProps } = useDropzone({ onDrop });\n  return (\n    <div {...getRootProps()} className=\"upload-area\">\n      <input {...getInputProps()} />\n      <p>{text}</p>\n    </div>\n  );\n};\n\nexport default UploadArea;\n","export function arrayBufferToString(buf: string | ArrayBuffer | null): string {\n  if (buf === null || typeof buf === \"string\") {\n    return '{\"error\":true}';\n  }\n  let jsonKey: string = \"\";\n  // ** works, but fails with unicode chars **\n  // new Uint8Array(buf).forEach(\n  //   (byte: number) => (jsonKey += String.fromCharCode(byte))\n  // );\n  jsonKey = new TextDecoder().decode(new Uint8Array(buf));\n  return jsonKey;\n}\n\nexport function stringToArrayBuffer(str: string) {\n  var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n","export const parseData = (data: string): any => {\n  // Get part of the string with actual instance data\n  const start = data.lastIndexOf('[\"instances\"] = ') + 17; // Only works if actual instance object is last in data set\n  const newStr = data.slice(start);\n\n  // Clean up the string and split it in separate objects\n  const enumRegexp = new RegExp(/, -- \\[\\d+\\]/, \"g\");\n  const instanceDataArray = newStr\n    .replaceAll(\"\\n\", \"\")\n    .replaceAll(\"\\r\", \"\")\n    .replaceAll(\"\\t\", \"\")\n    .replaceAll('[\"', '\"')\n    .replaceAll('\"]', '\"')\n    .replaceAll(\" = \", \":\")\n    .replaceAll(\",}\", \"}\")\n    .split(enumRegexp);\n\n  // Parse all valid objects\n  let parsedData: string[] = [];\n  instanceDataArray.forEach((el, idx) => {\n    try {\n      parsedData.push(JSON.parse(el));\n    } catch (e) {\n      // Ignore failed parses (random strings and AB instances)\n      // console.log(e);\n    }\n  });\n\n  return parsedData;\n};\n","import { ColorRangeInfo } from \"../Types/ArenaTypes\";\n\nfunction calculatePoint(\n  index: number,\n  intervalSize: number,\n  colorRangeInfo: ColorRangeInfo\n) {\n  const { colorStart, colorEnd, useEndAsStart } = colorRangeInfo;\n  return useEndAsStart\n    ? colorEnd - index * intervalSize\n    : colorStart + index * intervalSize;\n}\n\nexport default function generateChartColors(\n  dataLength: number,\n  colorScale: (i: number) => string,\n  colorRangeInfo: ColorRangeInfo,\n  targetArray: string[]\n) {\n  const { colorStart, colorEnd } = colorRangeInfo;\n  const colorRange = colorEnd - colorStart;\n  const intervalSize = colorRange / dataLength;\n  let i, colorPoint;\n\n  for (i = 0; i < dataLength; i++) {\n    colorPoint = calculatePoint(i, intervalSize, colorRangeInfo);\n    targetArray.push(colorScale(colorPoint));\n  }\n}\n\nexport {};\n","import React from \"react\";\nimport { Bar } from \"react-chartjs-2\";\nimport { interpolateTurbo } from \"d3-scale-chromatic\";\nimport {\n  ChartDataSet,\n  ColorRangeInfo,\n  SortableTeamCompObj,\n  TeamCompDataset,\n} from \"../Types/ArenaTypes\";\nimport generateChartColors from \"../utils/colorGeneration\";\n\ntype BarChartProps = {\n  dataset: TeamCompDataset;\n};\n\nconst BarChart: React.FC<BarChartProps> = ({ dataset }) => {\n  const colorRangeInfo: ColorRangeInfo = {\n    colorStart: 0.1,\n    colorEnd: 0.85,\n    useEndAsStart: true,\n  };\n  let totalMatchNumber = 0;\n  const labelArr: (string | string[])[] = [];\n  const dataArr: number[] = [];\n  const winsArr: number[] = [];\n  let colorArray: string[] = [];\n  const options: any = {\n    indexAxis: \"y\",\n    responsive: true,\n    scales: {\n      y: {\n        ticks: {\n          color: \"#292F36\",\n          font: { size: 15, family: \"'Roboto', sans-serif\" },\n          stepSize: 1,\n          beginAtZero: true,\n        },\n      },\n    },\n    plugins: {\n      tooltip: {\n        callbacks: {\n          afterLabel: (tooltip: any) => {\n            const index = tooltip.dataIndex;\n            const wins = tooltip.dataset.wins[index];\n            const matchCount = tooltip.dataset.data[index];\n            const winrate: string = ((wins / matchCount) * 100).toFixed(1);\n            const textToDisplay = [\n              `Wins: ${wins}, Losses: ${matchCount - wins}`,\n              `WR: ${winrate}%`,\n            ];\n            return textToDisplay;\n          },\n        },\n      },\n      legend: {\n        display: false,\n      },\n    },\n  };\n  const data: ChartDataSet = {\n    labels: labelArr,\n    datasets: [\n      {\n        label: \"\",\n        data: dataArr,\n        wins: winsArr,\n        backgroundColor: colorArray,\n        borderColor: [],\n        borderWidth: 1,\n        hoverOffset: 6,\n      },\n    ],\n  };\n\n  const datasetKeys = Object.getOwnPropertyNames(dataset);\n  const sortableEntries: SortableTeamCompObj[] = [];\n  datasetKeys.forEach((key) => {\n    const { matchCount, wins } = dataset[key];\n    sortableEntries.push({ teamComp: key, matchCount, wins });\n  });\n  sortableEntries.sort((a, b) => b.matchCount - a.matchCount);\n  sortableEntries.forEach((entry) => {\n    const { matchCount, wins, teamComp } = entry;\n    totalMatchNumber += matchCount;\n    labelArr.push([teamComp]);\n    dataArr.push(matchCount);\n    winsArr.push(wins);\n  });\n  generateChartColors(\n    sortableEntries.length,\n    interpolateTurbo,\n    colorRangeInfo,\n    colorArray\n  );\n\n  const chartTitle: string = `Matches Played: ${totalMatchNumber}`;\n\n  return (\n    <>\n      <div className=\"header\">\n        <h1 className=\"title\">{chartTitle}</h1>\n      </div>\n      <Bar data={data} options={options} />\n    </>\n  );\n};\n\nexport default BarChart;\n","import React, { useEffect, useState } from \"react\";\nimport UploadArea from \"./UploadArea\";\nimport { localStorageToState } from \"../utils/stateManagement\";\nimport { ModdedArenaMatch, TeamCompDataset } from \"../Types/ArenaTypes\";\nimport BarChart from \"./BarChart\";\nimport { createBasicChartDataset } from \"../utils/dataSetHelpers\";\n\nexport type dashboardProps = {\n  className?: string;\n};\n\nconst Dashboard: React.FC<dashboardProps> = (props) => {\n  let [matchData, setMatchData] = useState<ModdedArenaMatch[]>([]);\n  let [localStorageChanged, setLocalStorageChanged] = useState<boolean>(false);\n  let [chartDataset, setChartDataset] = useState<TeamCompDataset>({});\n  useEffect(() => localStorageToState(setMatchData), [localStorageChanged]);\n  useEffect(\n    () => setChartDataset(createBasicChartDataset(matchData)),\n    [matchData]\n  );\n\n  return (\n    <div className=\"dashboard\">\n      <div className=\"dashboard__top-bar\">\n        <UploadArea\n          lcHandler={setLocalStorageChanged}\n          lcVal={localStorageChanged}\n        />\n        <div className=\"dashboard__filters\">\n          <div className=\"dashboard__filters-btn\" onClick={() => {}}>\n            All data\n          </div>\n          <div className=\"dashboard__filters-btn\">Last session</div>\n        </div>\n      </div>\n      {matchData && (\n        <div className=\"dashboard__chart-container\">\n          <BarChart dataset={chartDataset} />\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Dashboard;\n","import React from \"react\";\nimport \"./App.css\";\nimport Dashboard from \"./components/Dashboard\";\n\nfunction App() {\n  return (\n    <div className=\"main-wrap\">\n      <Dashboard />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"normalize.css\";\nimport \"./styles/index.scss\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}