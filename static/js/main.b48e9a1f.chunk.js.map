{"version":3,"sources":["utils/stateManagement.tsx","utils/dataSetHelpers.tsx","components/UploadArea.tsx","utils/ArrayBuffer-StringHelper.tsx","utils/parseData.tsx","utils/colorGeneration.tsx","components/BarChart.tsx","utils/dateManagement.tsx","components/SessionSelect.tsx","components/Dashboard.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["INSTANCE_DATA","MY_CHAR_NAME","setLocalStorageField","key","data","localStorage","setItem","JSON","stringify","DISCONNECTED","ARENA_INSTANCE_IDS","PLAYER_KEYS","filterArenaMatches","myCharName","filterSkirmish","filteredData","filter","match","playerName","modifiedData","forEach","moddedMatch","enteredTime","instanceID","instanceName","enemyTeamComp","myTeamComp","bracket","myTeam","enemyTeam","win","moddedMatchData","goldTeam","hasOwnProperty","purpleTeam","winningFaction","myTeamNames","Object","keys","enemyTeamNames","myTeamPlayerCount","length","enemyTeamPlayerCount","Math","max","arenaBracket","i","push","fillNameArraysWithBlanks","myModdedTeam","enemyModdedTeam","name","idx","getModdedTeamsAndTeamComps","sort","getModdedArenaData","assign","filteredSkirmishes","player1","teamMMR","teamObj","moddedTeamObj","compArr","playerDCed","class","fillTeamCompObject","obj","matchCount","wins","Number","UploadArea","localStoreChangeHandler","localStorageChangeValue","useState","text","setText","onDrop","useCallback","acceptedFiles","file","reader","FileReader","onabort","onerror","onload","buf","binaryStr","result","state","window","getItem","parsedState","parse","mergedState","filteredState","Map","map","item","values","mergeState","start","lastIndexOf","newStr","slice","enumRegexp","RegExp","instanceDataArray","replaceAll","split","parsedData","el","e","parseData","TextDecoder","decode","Uint8Array","includes","readAsArrayBuffer","useDropzone","getRootProps","getInputProps","className","calculatePoint","index","intervalSize","colorRangeInfo","colorStart","colorEnd","useEndAsStart","calcWinrate","toFixed","BarChart","totalLosses","totalWinrate","dataset","totalMatchNumber","totalWins","labelArr","dataArr","winsArr","colorArray","options","indexAxis","responsive","scales","y","ticks","color","font","size","family","stepSize","beginAtZero","plugins","tooltip","callbacks","afterLabel","dataIndex","winrate","legend","display","labels","datasets","label","backgroundColor","borderColor","borderWidth","hoverOffset","datasetKeys","getOwnPropertyNames","sortableEntries","teamComp","a","b","entry","dataLength","colorScale","targetArray","colorPoint","generateChartColors","interpolateTurbo","chartTitle","dayjs","extend","isBetween","SessionSelect","sessionData","onChange","selected","setSelected","valueRef","useRef","current","sessionKeys","selectAllOption","value","timestamp","formattedData","unix","format","sessionOption","reverse","isSelectAllSelected","classNamePrefix","defaultValue","isOptionSelected","option","some","newValue","actionMeta","selectedTimestampArray","action","removedValue","filteredOptions","hideSelectedOptions","closeMenuOnSelect","isMulti","Dashboard","useForm","register","handleSubmit","setMyCharName","matchData","setMatchData","setSessionData","sessionSelection","setSessionSelection","localStorageChanged","setLocalStorageChanged","chartDataset","setChartDataset","useEffect","setReactState","currentState","localStorageToState","lsMatchState","lsCharNameState","stateIsPresent","parsedMatchData","parsedCharData","matches","matchSessions","prevMatch","sessionKey","every","prevMatchEnterTime","add","getSessions","selectedMatches","hasDCedPlayers","enemyTeamCompString","reduce","concat","createBasicChartDataset","onSubmit","charName","placeholder","type","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"wOAGaA,EAAgB,eAChBC,EAAe,aA4BrB,SAASC,EAAqBC,EAAaC,GAChDC,aAAaC,QAAQH,EAAKI,KAAKC,UAAUJ,ICxB3C,IAAMK,EAAe,gBAEfC,EAA+B,CAAC,IAAK,IAAK,KAC1CC,EAAiC,CACrC,UACA,UACA,UACA,UACA,WAYK,SAASC,EACdR,EACAS,EACAC,GAEA,IAAMC,EAAeX,EAAKY,QAAO,SAACC,GAChC,OAAOA,EAAMC,aAAeL,KAE1BM,EAAmC,GAmBvC,GAlBAJ,EAAaK,SAAQ,SAACH,GACpB,IAAMI,EAAgC,CACpCC,YAAaL,EAAMK,YACnBC,WAAYN,EAAMM,WAClBC,aAAcP,EAAMO,aACpBN,WAAYD,EAAMC,WAClBO,cAAe,GACfC,WAAY,GACZC,QAAS,EACTC,OAAQ,GACRC,UAAW,GACXC,KAAK,GAGDC,EAiBV,SAA4Bd,GAC1B,IAAIW,EAAmBC,EAAsBC,EACvCjB,EAAaI,EAAMC,WACrBD,EAAMe,SAASC,eAAepB,IAChCe,EAASX,EAAMe,SACfH,EAAYZ,EAAMiB,WAClBJ,IAAQb,EAAMkB,iBAEdP,EAASX,EAAMiB,WACfL,EAAYZ,EAAMe,SAClBF,GAAOb,EAAMkB,gBAGf,IAAMC,EAAiCC,OAAOC,KAAKV,GAC7CW,EAAoCF,OAAOC,KAAKT,GAChDW,EAAoBJ,EAAYK,OAChCC,EAAuBH,EAAeE,OACtCd,EAAUgB,KAAKC,IAAIJ,EAAmBE,IA+C9C,SACEN,EACAG,EACAM,GAEA,GAAIT,EAAYK,OAASI,EACvB,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAeT,EAAYK,OAAQK,IACrDV,EAAYW,KAAK,MAGrB,GAAIR,EAAeE,OAASI,EAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAeN,EAAeE,OAAQK,IACxDP,EAAeQ,KAAK,MA1DxBC,CAAyBZ,EAAaG,EAAgBZ,GAGtD,IAAIsB,EAAgC,GAChCvB,EAAuB,GACvBwB,EAAmC,GACnCzB,EAA0B,GAa9B,OAZAW,EAAYhB,SAAQ,SAAC+B,EAAMC,GAAP,OAClBC,EAA2BF,EAAMC,EAAKxB,EAAQqB,EAAcvB,MAE9Da,EAAenB,SAAQ,SAAC+B,EAAMC,GAAP,OACrBC,EACEF,EACAC,EACAvB,EACAqB,EACAzB,MAGG,CACLE,UACAG,MACAF,OAAQqB,EACRvB,WAAYA,EAAW4B,OACvBzB,UAAWqB,EACXzB,cAAeA,EAAc6B,QA5DLC,CAAmBtC,GAC3CoB,OAAOmB,OAAOnC,EAAaU,GAC3BZ,EAAa4B,KAAK1B,MAEhBP,EAAgB,CAClB,IAAM2C,EAAqBtC,EAAaH,QACtC,SAACC,GAAD,gBAEsC,KAAlC,UAAAA,EAAMW,OAAO8B,eAAb,eAAsBC,UACe,KAArC,UAAA1C,EAAMY,UAAU6B,eAAhB,eAAyBC,aAG/BxC,EAAesC,EAEjB,OAAOtC,EAkDT,SAASkC,EACPF,EACAC,EACAQ,EACAC,EACAC,GAEA,IAAMC,EAAsB,OAATZ,EACnBU,EAAclD,EAAYyC,IAAQW,EAC9B,KADwC,aAGtCZ,KAAMA,GACHS,EAAQT,IAEjBW,EAAQf,KAAKgB,EAAatD,EAAemD,EAAQT,GAAMa,OAuCzD,SAASC,EACPC,EACA/D,EACAc,GAEIiD,EAAI/D,IACN+D,EAAI/D,GAAKgE,YAAc,EACvBlD,EAAMa,KAAOoC,EAAI/D,GAAKiE,QAEtBF,EAAI/D,GAAO,CAAEgE,WAAY,EAAGC,KAAMC,OAAOpD,EAAMa,M,WCpIpCwC,EAlC4B,SAAC,GAGrC,IAFLC,EAEI,EAFJA,wBACAC,EACI,EADJA,wBACI,EACoBC,mBAAS,oBAD7B,mBACGC,EADH,KACSC,EADT,KAGEC,EAASC,uBACb,SAACC,GACCA,EAAc1D,SAAQ,SAAC2D,GAErB,IAAMC,EAAS,IAAIC,WAEnBD,EAAOE,QAAU,kBAAMP,EAAQ,6BAC/BK,EAAOG,QAAU,kBAAMR,EAAQ,wBAC/BK,EAAOI,OAAS,WACd,IDPqBhF,EEpBKiF,ED2BpBC,EAAYN,EAAOO,QFrB5B,SAAoBxE,GACzB,IACMyE,EAAQC,OAAOpF,aAAaqF,QAAQ1F,GAE1C,GAAKwF,EAAL,CAIA,IAAMG,EAAcpF,KAAKqF,MAAMJ,GACzBK,EAAW,sBAAOF,GAAP,YAAuB5E,IAElC+E,EAAa,YACd,IAAIC,IAAIF,EAAYG,KAAI,SAACC,GAAD,MAAU,CAACA,EAAI,YAAaA,OAAQC,UAGjEhG,EAAqBF,EAAe8F,QAVlC5F,EAAqBF,EAAee,GEiB9BoF,EDRqB/F,EGlBN,SAACA,GAExB,IAAMgG,EAAQhG,EAAKiG,YAAY,oBAAsB,GAC/CC,EAASlG,EAAKmG,MAAMH,GAGpBI,EAAa,IAAIC,OAAO,eAAgB,KACxCC,EAAoBJ,EACvBK,WAAW,KAAM,IACjBA,WAAW,KAAM,IACjBA,WAAW,KAAM,IACjBA,WAAW,KAAM,KACjBA,WAAW,KAAM,KACjBA,WAAW,MAAO,KAClBA,WAAW,KAAM,KACjBC,MAAMJ,GAGLK,EAA2B,GAS/B,OARAH,EAAkBtF,SAAQ,SAAC0F,EAAI1D,GAC7B,IACEyD,EAAW9D,KAAKxC,KAAKqF,MAAMkB,IAC3B,MAAOC,QAKJF,EFD2BG,EC5BA3B,ED4B8BC,EC3BpD,OAARD,GAA+B,kBAARA,EAClB,kBAOC,IAAI4B,aAAcC,OAAO,IAAIC,WAAW9B,MFY3CjF,EAAKY,QACV,SAACC,GAAD,OACEP,EAAmB0G,SAASnG,EAAMM,aAClCN,EAAMgB,eAAe,eACrBhB,EAAMgB,eAAe,iBCIjBsC,GAAyBC,GACzBG,EAAQ,6BAEVK,EAAOqC,kBAAkBtC,QAG7B,CAACR,EAAyBC,IApBxB,EAsBoC8C,YAAY,CAAE1C,WAA9C2C,EAtBJ,EAsBIA,aAAcC,EAtBlB,EAsBkBA,cACtB,OACE,gDAASD,KAAT,IAAyBE,UAAU,cAAnC,UACE,qCAAWD,MACX,4BAAI9C,S,iBGvCV,SAASgD,EACPC,EACAC,EACAC,GACC,IACOC,EAAwCD,EAAxCC,WAAYC,EAA4BF,EAA5BE,SACpB,OADgDF,EAAlBG,cAE1BD,EAAWJ,EAAQC,EACnBE,EAAaH,EAAQC,ECK3B,SAASK,EAAY9D,EAAoBC,GACvC,OAASA,EAAOD,EAAc,KAAK+D,QAAQ,GAG7C,IAiGeC,EAjG2B,SAAC,GAAiB,IAQtDC,EACAC,EATuCC,EAAc,EAAdA,QAMvCC,EAAmB,EACnBC,EAAY,EAGVC,EAAkC,GAClCC,EAAoB,GACpBC,EAAoB,GACtBC,EAAuB,GACrBC,EAAe,CACnBC,UAAW,IACXC,YAAY,EACZC,OAAQ,CACNC,EAAG,CACDC,MAAO,CACLC,MAAO,UACPC,KAAM,CAAEC,KAAM,GAAIC,OAAQ,wBAC1BC,SAAU,EACVC,aAAa,KAInBC,QAAS,CACPC,QAAS,CACPC,UAAW,CACTC,WAAY,SAACF,GACX,IAAM/B,EAAQ+B,EAAQG,UAChBzF,EAAOsF,EAAQpB,QAAQlE,KAAKuD,GAC5BxD,EAAauF,EAAQpB,QAAQlI,KAAKuH,GAClCmC,EAAkB7B,EAAY9D,EAAYC,GAChD,MAAO,CAAC,SAAD,OACIA,EADJ,qBACqBD,EAAaC,GADlC,cAEE0F,EAFF,SAObC,OAAQ,CACNC,SAAS,KAIT5J,EAAqB,CACzB6J,OAAQxB,EACRyB,SAAU,CACR,CACEC,MAAO,GACP/J,KAAMsI,EACNtE,KAAMuE,EACNyB,gBAAiBxB,EACjByB,YAAa,GACbC,YAAa,EACbC,YAAa,KAKbC,EAAcnI,OAAOoI,oBAAoBnC,GACzCoC,EAAyC,GAC/CF,EAAYpJ,SAAQ,SAACjB,GAAS,IAAD,EACEmI,EAAQnI,GAA7BgE,EADmB,EACnBA,WAAYC,EADO,EACPA,KACpBsG,EAAgB3H,KAAK,CAAE4H,SAAUxK,EAAKgE,aAAYC,YAEpDsG,EAAgBpH,MAAK,SAACsH,EAAGC,GAAJ,OAAUA,EAAE1G,WAAayG,EAAEzG,cAChDuG,EAAgBtJ,SAAQ,SAAC0J,GAAW,IAC1B3G,EAA+B2G,EAA/B3G,WAAYC,EAAmB0G,EAAnB1G,KAAMuG,EAAaG,EAAbH,SAC1BpC,GAAoBpE,EACpBqE,GAAapE,EACbqE,EAAS1F,KAAK,CAAC4H,IACfjC,EAAQ3F,KAAKoB,GACbwE,EAAQ5F,KAAKqB,MDjFF,SACb2G,EACAC,EACAnD,EACAoD,GACC,IAIGnI,EAAGoI,EAHCpD,EAAyBD,EAAzBC,WAEFF,GAF2BC,EAAbE,SACUD,GACIiD,EAGlC,IAAKjI,EAAI,EAAGA,EAAIiI,EAAYjI,IAC1BoI,EAAaxD,EAAe5E,EAAG8E,EAAcC,GAC7CoD,EAAYlI,KAAKiI,EAAWE,ICsE9BC,CACET,EAAgBjI,OAChB2I,IA9EqC,CACrCtD,WAAY,GACZC,SAAU,IACVC,eAAe,GA6EfY,GAEFR,EAAcG,EAAmBC,EACjCH,EAAeJ,EAAYM,EAAkBC,GAC7C,IAAM6C,EAAkB,0BAAsB9C,EAAtB,mBAAiDC,EAAjD,qBAAuEJ,EAAvE,iBAA2FC,EAA3F,MAExB,OACE,qCACE,qBAAKZ,UAAU,SAAf,SACE,oBAAIA,UAAU,QAAd,SAAuB4D,MAEzB,cAAC,IAAD,CAAKjL,KAAMA,EAAMyI,QAASA,Q,kCC5GhCyC,IAAMC,OAAOC,K,YC+FEC,EAxFqC,SAAC,GAG9C,IAFLC,EAEI,EAFJA,YACAC,EACI,EADJA,SACI,EAC4BlH,mBAA0C,IADtE,mBACGmH,EADH,KACaC,EADb,KAEEC,EAAWC,iBAAOH,GACxBE,EAASE,QAAUJ,EAEnB,IAAMK,EAAwB5J,OAAOoI,oBAAoBiB,GACnDQ,EAAuC,CAC3CC,MAAO,EACPhC,MAAO,YAEHtB,EAAiC,GACvCoD,EAAY7K,SAAQ,SAACjB,EAAKiD,GACxB,IAAMgJ,EAAoB/H,OAAOlE,GAC3BkM,EAAwBf,IAC3BgB,KAAKF,GACLG,OAAO,oBACJC,EAAgB,CACpBL,MAAOC,EACPjC,MAAM,WAAD,OAAa/G,EAAM,EAAnB,eAA2BiJ,IAElCxD,EAAQ9F,KAAKyJ,MAEf3D,EAAQ4D,UAER,IAAMC,EAAsB,wBAClB,OAARZ,QAAQ,IAARA,GAAA,UAAAA,EAAUE,eAAV,eAAmBvJ,UAAWoG,EAAQpG,QA4CxC,OACE,cAAC,IAAD,CACEgF,UAAW,iBACXkF,gBAAiB,iBACjBC,aAAcV,EACdW,iBA7CqB,SAACC,GAAD,aACf,OAARhB,QAAQ,IAARA,GAAA,UAAAA,EAAUE,eAAV,eAAmBe,MAAK,qBAAGZ,QAAsBW,EAAOX,WACxDO,KA4CE7D,QAhDe,CAAOqD,GAAP,OAA2BrD,GAiD1CsD,MA3CoBO,IAAwB,CAACR,GAAmBN,EA4ChED,SA1CiB,SACnBqB,EACAC,GAEA,IAAMC,EAAmC,GACjCC,EAAiCF,EAAjCE,OAAQL,EAAyBG,EAAzBH,OAAQM,EAAiBH,EAAjBG,aACxB,GAAe,kBAAXD,IAAoC,OAANL,QAAM,IAANA,OAAA,EAAAA,EAAQX,SAAUD,EAAgBC,MAClEN,EAAYhD,GACZqE,EAAuBnK,KAAvB,MAAAmK,EAAsB,YAASrE,EAAQ7C,KAAI,SAAC8G,GAAD,OAAYA,EAAOX,gBACzD,GACO,oBAAXgB,IACO,OAANL,QAAM,IAANA,OAAA,EAAAA,EAAQX,SAAUD,EAAgBC,OACxB,iBAAXgB,IACa,OAAZC,QAAY,IAAZA,OAAA,EAAAA,EAAcjB,SAAUD,EAAgBC,MAE1CN,EAAY,SACP,GACiB,oBAAtBoB,EAAWE,QACXT,IACA,CACA,IAAMW,EAAkBxE,EAAQ7H,QAC9B,qBAAGmL,SAAiB,OAAKW,QAAL,IAAKA,OAAL,EAAKA,EAAQX,UAEnCN,EAAYwB,GACZH,EAAuBnK,KAAvB,MAAAmK,EAAsB,YACjBG,EAAgBrH,KAAI,SAAC8G,GAAD,OAAYA,EAAOX,gBAG5CN,EAAYmB,GAAY,IACxBE,EAAuBnK,KAAvB,MAAAmK,EAAsB,YAASF,EAAShH,KAAI,SAAC8G,GAAD,OAAYA,EAAOX,WAEjER,GAAYA,EAASuB,IAYnBI,qBAAqB,EACrBC,mBAAmB,EACnBC,SAAO,KCYEC,EA7E6B,WAAO,IAAD,EACbC,cAA3BC,EADwC,EACxCA,SAAUC,EAD8B,EAC9BA,aAD8B,EAEZnJ,mBAAiB,IAFL,mBAEzC5D,EAFyC,KAE7BgN,EAF6B,OAGdpJ,mBAA6B,IAHf,mBAGzCqJ,EAHyC,KAG9BC,EAH8B,OAIVtJ,mBAAwB,IAJd,mBAIzCiH,EAJyC,KAI5BsC,EAJ4B,OAKAvJ,mBAAmB,CAAC,IALpB,mBAKzCwJ,EALyC,KAKvBC,EALuB,OAO9CzJ,oBAAkB,GAP4B,mBAMzC0J,EANyC,KAMpBC,EANoB,OAQR3J,mBAA0B,IARlB,mBAQzC4J,EARyC,KAQ3BC,EAR2B,KAUhDC,qBAAU,YTdL,SACLpO,EACAqO,GAEA,IAAMC,EAAehJ,OAAOpF,aAAaqF,QAAQvF,GACjDsO,GAAgBD,EAAcjO,KAAKqF,MAAM6I,ISUvCC,CAAoBzO,EAAc4N,KACjC,IACHU,qBAAU,WACR,IAAMI,EAAelJ,OAAOpF,aAAaqF,QAAQ1F,GAC3C4O,EAAkBnJ,OAAOpF,aAAaqF,QAAQzF,GAC9C4O,EAAiBF,GAAgBC,EACvC,GAAIC,EAAgB,CAClB,IAAMC,EAAkBvO,KAAKqF,MAAM+I,GAC7BI,EAAiBxO,KAAKqF,MAAMgJ,GAElC,GADAC,GAAkBb,EF3CjB,SAAqBgB,GAC1B,IAAMC,EAA+B,GACrCD,EAAQ1L,MAAK,SAACsH,EAAGC,GAAJ,OAAUD,EAAEtJ,YAAcuJ,EAAEvJ,eAEzC,IACI4N,EADAC,EAA4B,KAyBhC,OAvBAH,EAAQI,OAAM,SAACnO,GACb,GAAIkO,EAAY,CAEd,IAAME,EAAqB/D,IAAMgB,KAAK4C,EAAU5N,aAMhD,GALgCgK,IAC7BgB,KAAKrL,EAAMK,aACXkK,UAAU6D,EAAoBA,EAAmBC,IAAI,EAAG,SAMzD,OAFAL,EAAcE,GAAYpM,KAAK9B,GAC/BiO,EAAYjO,GACL,EAQX,OAHAkO,EAAalO,EAAMK,YACnB4N,EAAYjO,EACZgO,EAAcE,GAAc,CAAClO,IACtB,KAGFgO,EEc8BM,CAAYT,IACzCb,EAAiB7G,SAAS,GAC5B2G,EAAanN,EAAmBkO,EAAiBC,GAAgB,QAC5D,CACL,IAAMS,EAAgC,GACtCvB,EAAiB7M,SAAQ,SAAC+N,GACxBK,EAAgBzM,KAAhB,MAAAyM,EAAe,YAAS9D,EAAYyD,QAEtCpB,EAAanN,EAAmB4O,EAAiBT,GAAgB,QAGpE,CAACZ,EAAqBF,IACzBM,qBACE,kBAAMD,ERyFH,SACLlO,GAEA,IAAMkI,EAA2B,GAajC,OAZAlI,EAAKgB,SAAQ,SAACH,GACZ,IAAMwO,EACJxO,EAAMQ,cAAc2F,SAAS3G,IAC7BQ,EAAMS,WAAW0F,SAAS3G,GACtBiP,EAA0CzO,EAAMQ,cAyB7CkO,QAAO,SAAC/E,EAAGC,GAAJ,OAAUD,EAAEgF,OAAO,OAAQ/E,MAvBzC5G,EAAmBqE,EADjBmH,EAC0B,KAEAC,EAFMzO,MAM/BqH,EQzGiBuH,CAAwB/B,MAC9C,CAACA,IAQH,OACE,sBAAKrG,UAAU,YAAf,UACE,sBAAKA,UAAU,qBAAf,UACE,cAAC,EAAD,CACElD,wBAAyB6J,EACzB5J,wBAAyB2J,IAE3B,sBAAK1G,UAAU,qBAAf,UACE,uBAAMqI,SAAUlC,GAbP,SAACxN,GAChBF,EAAqBD,EAAcG,EAAK2P,UACxC3B,GAAwBD,MAWlB,UACE,+CACE1G,UAAU,6BACNkG,EAAS,aAFf,IAGEqC,YAAW,UAAKnP,MAElB,wBAAQ4G,UAAU,6BAA6BwI,KAAK,SAApD,uBAIDvE,GACC,cAAC,EAAD,CACEC,SAAUuC,EACVxC,YAAaA,UAKpBoC,GACC,qBAAKrG,UAAU,6BAAf,SACE,cAAC,EAAD,CAAUa,QAAS+F,UCtFd6B,MARf,WACE,OACE,qBAAKzI,UAAU,YAAf,SACE,cAAC,EAAD,OCOS0I,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCFdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,K","file":"static/js/main.b48e9a1f.chunk.js","sourcesContent":["import React from \"react\";\nimport { ArenaMatch } from \"../Types/ArenaTypes\";\n\nexport const INSTANCE_DATA = \"instanceData\";\nexport const MY_CHAR_NAME = \"myCharName\";\n\nexport function mergeState(filteredData: ArenaMatch[]): void {\n  const filterKey = \"enteredTime\";\n  const state = window.localStorage.getItem(INSTANCE_DATA);\n\n  if (!state) {\n    setLocalStorageField(INSTANCE_DATA, filteredData);\n    return;\n  }\n  const parsedState = JSON.parse(state);\n  const mergedState = [...parsedState, ...filteredData];\n\n  const filteredState = [\n    ...new Map(mergedState.map((item) => [item[filterKey], item])).values(),\n  ];\n\n  setLocalStorageField(INSTANCE_DATA, filteredState);\n}\n\nexport function localStorageToState(\n  key: string,\n  setReactState: React.Dispatch<React.SetStateAction<any>>\n): void {\n  const currentState = window.localStorage.getItem(key);\n  currentState && setReactState(JSON.parse(currentState));\n}\n\nexport function setLocalStorageField(key: string, data: any): void {\n  localStorage.setItem(key, JSON.stringify(data));\n}\n","import {\n  ArenaMatch,\n  arenaPlayerKeys,\n  ArenaTeam,\n  ModdedArenaMatch,\n  ModdedArenaTeam,\n  TeamCompDataset,\n} from \"../Types/ArenaTypes\";\n\nconst DISCONNECTED = \"!disconnected\";\n// const MY_TEAMMATE_NAME: string = \"Induator\";\nconst ARENA_INSTANCE_IDS: number[] = [572, 562, 559]; // \"Ruins of Lordaeron\", \"Blade's Edge Arena\", \"Nagrand Arena\"\nconst PLAYER_KEYS: arenaPlayerKeys[] = [\n  \"player1\",\n  \"player2\",\n  \"player3\",\n  \"player4\",\n  \"player5\",\n];\n\nexport function filterJunkData(data: ArenaMatch[]): ArenaMatch[] {\n  return data.filter(\n    (match) =>\n      ARENA_INSTANCE_IDS.includes(match.instanceID) &&\n      match.hasOwnProperty(\"purpleTeam\") &&\n      match.hasOwnProperty(\"goldTeam\")\n  );\n}\n\nexport function filterArenaMatches(\n  data: ArenaMatch[],\n  myCharName: string,\n  filterSkirmish: boolean\n): ModdedArenaMatch[] {\n  const filteredData = data.filter((match) => {\n    return match.playerName === myCharName;\n  });\n  let modifiedData: ModdedArenaMatch[] = [];\n  filteredData.forEach((match) => {\n    const moddedMatch: ModdedArenaMatch = {\n      enteredTime: match.enteredTime,\n      instanceID: match.instanceID,\n      instanceName: match.instanceName,\n      playerName: match.playerName,\n      enemyTeamComp: [],\n      myTeamComp: [],\n      bracket: 0,\n      myTeam: {},\n      enemyTeam: {},\n      win: false,\n    };\n\n    const moddedMatchData = getModdedArenaData(match);\n    Object.assign(moddedMatch, moddedMatchData);\n    modifiedData.push(moddedMatch);\n  });\n  if (filterSkirmish) {\n    const filteredSkirmishes = modifiedData.filter(\n      (match) =>\n        !(\n          match.myTeam.player1?.teamMMR === 0 &&\n          match.enemyTeam.player1?.teamMMR === 0\n        )\n    );\n    modifiedData = filteredSkirmishes;\n  }\n  return modifiedData;\n}\n\nfunction getModdedArenaData(match: ArenaMatch): any {\n  let myTeam: ArenaTeam, enemyTeam: ArenaTeam, win: boolean;\n  const myCharName = match.playerName;\n  if (match.goldTeam.hasOwnProperty(myCharName)) {\n    myTeam = match.goldTeam;\n    enemyTeam = match.purpleTeam;\n    win = !!match.winningFaction; //WIN\n  } else {\n    myTeam = match.purpleTeam;\n    enemyTeam = match.goldTeam;\n    win = !match.winningFaction; //WIN\n  }\n\n  const myTeamNames: (string | null)[] = Object.keys(myTeam);\n  const enemyTeamNames: (string | null)[] = Object.keys(enemyTeam);\n  const myTeamPlayerCount = myTeamNames.length;\n  const enemyTeamPlayerCount = enemyTeamNames.length;\n  const bracket = Math.max(myTeamPlayerCount, enemyTeamPlayerCount); // BRACKET\n  fillNameArraysWithBlanks(myTeamNames, enemyTeamNames, bracket);\n\n  // modded arena team\n  let myModdedTeam: ModdedArenaTeam = {};\n  let myTeamComp: string[] = [];\n  let enemyModdedTeam: ModdedArenaTeam = {};\n  let enemyTeamComp: string[] = [];\n  myTeamNames.forEach((name, idx) =>\n    getModdedTeamsAndTeamComps(name, idx, myTeam, myModdedTeam, myTeamComp)\n  );\n  enemyTeamNames.forEach((name, idx) =>\n    getModdedTeamsAndTeamComps(\n      name,\n      idx,\n      enemyTeam,\n      enemyModdedTeam,\n      enemyTeamComp\n    )\n  );\n  return {\n    bracket,\n    win,\n    myTeam: myModdedTeam,\n    myTeamComp: myTeamComp.sort(),\n    enemyTeam: enemyModdedTeam,\n    enemyTeamComp: enemyTeamComp.sort(),\n  };\n}\n\nfunction getModdedTeamsAndTeamComps(\n  name: string | null,\n  idx: number,\n  teamObj: ArenaTeam,\n  moddedTeamObj: ModdedArenaTeam,\n  compArr: string[]\n) {\n  const playerDCed = name === null;\n  moddedTeamObj[PLAYER_KEYS[idx]] = playerDCed\n    ? null\n    : {\n        name: name,\n        ...teamObj[name],\n      };\n  compArr.push(playerDCed ? DISCONNECTED : teamObj[name].class);\n}\n\nfunction fillNameArraysWithBlanks(\n  myTeamNames: (string | null)[],\n  enemyTeamNames: (string | null)[],\n  arenaBracket: number\n): void {\n  if (myTeamNames.length < arenaBracket) {\n    for (let i = 0; i < arenaBracket - myTeamNames.length; i++) {\n      myTeamNames.push(null);\n    }\n  }\n  if (enemyTeamNames.length < arenaBracket) {\n    for (let i = 0; i < arenaBracket - enemyTeamNames.length; i++) {\n      enemyTeamNames.push(null);\n    }\n  }\n}\n\nexport function createBasicChartDataset(\n  data: ModdedArenaMatch[]\n): TeamCompDataset {\n  const dataset: TeamCompDataset = {};\n  data.forEach((match) => {\n    const hasDCedPlayers =\n      match.enemyTeamComp.includes(DISCONNECTED) ||\n      match.myTeamComp.includes(DISCONNECTED);\n    const enemyTeamCompString = teamcompArrToString(match.enemyTeamComp);\n    if (hasDCedPlayers) {\n      fillTeamCompObject(dataset, \"DC\", match);\n    } else {\n      fillTeamCompObject(dataset, enemyTeamCompString, match);\n    }\n  });\n\n  return dataset;\n}\n\nfunction fillTeamCompObject(\n  obj: TeamCompDataset,\n  key: string,\n  match: ModdedArenaMatch\n): void {\n  if (obj[key]) {\n    obj[key].matchCount += 1;\n    match.win && obj[key].wins++;\n  } else {\n    obj[key] = { matchCount: 1, wins: Number(match.win) };\n  }\n}\n\nfunction teamcompArrToString(arr: string[]): string {\n  return arr.reduce((a, b) => a.concat(\" \\\\ \", b));\n}\n","import React, { useCallback, useState } from \"react\";\nimport { parseData } from \"../utils/parseData\";\nimport { arrayBufferToString } from \"../utils/ArrayBuffer-StringHelper\";\nimport { useDropzone } from \"react-dropzone\";\nimport { mergeState } from \"../utils/stateManagement\";\nimport { filterJunkData } from \"../utils/dataSetHelpers\";\n\nexport type landingProps = {\n  localStoreChangeHandler: React.Dispatch<React.SetStateAction<boolean>>;\n  localStorageChangeValue: boolean;\n};\n\nconst UploadArea: React.FC<landingProps> = ({\n  localStoreChangeHandler,\n  localStorageChangeValue,\n}) => {\n  const [text, setText] = useState(\"Upload file here\");\n\n  const onDrop = useCallback(\n    (acceptedFiles) => {\n      acceptedFiles.forEach((file: any) => {\n        //TBD\n        const reader = new FileReader();\n\n        reader.onabort = () => setText(\"File reading was aborted\");\n        reader.onerror = () => setText(\"File reading failed\");\n        reader.onload = () => {\n          const binaryStr = reader.result;\n          mergeState(filterJunkData(parseData(arrayBufferToString(binaryStr))));\n          localStoreChangeHandler(!localStorageChangeValue);\n          setText(\"File successfully parsed\");\n        };\n        reader.readAsArrayBuffer(file);\n      });\n    },\n    [localStoreChangeHandler, localStorageChangeValue]\n  );\n  const { getRootProps, getInputProps } = useDropzone({ onDrop });\n  return (\n    <div {...getRootProps()} className=\"upload-area\">\n      <input {...getInputProps()} />\n      <p>{text}</p>\n    </div>\n  );\n};\n\nexport default UploadArea;\n","export function arrayBufferToString(buf: string | ArrayBuffer | null): string {\n  if (buf === null || typeof buf === \"string\") {\n    return '{\"error\":true}';\n  }\n  let jsonKey: string = \"\";\n  // ** works, but fails with unicode chars **\n  // new Uint8Array(buf).forEach(\n  //   (byte: number) => (jsonKey += String.fromCharCode(byte))\n  // );\n  jsonKey = new TextDecoder().decode(new Uint8Array(buf));\n  return jsonKey;\n}\n\nexport function stringToArrayBuffer(str: string) {\n  var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n","import { ArenaMatch } from \"../Types/ArenaTypes\";\n\nexport const parseData = (data: string): ArenaMatch[] => {\n  // Get part of the string with actual instance data\n  const start = data.lastIndexOf('[\"instances\"] = ') + 17; // Only works if actual instance object is last in data set\n  const newStr = data.slice(start);\n\n  // Clean up the string and split it in separate objects\n  const enumRegexp = new RegExp(/, -- \\[\\d+\\]/, \"g\");\n  const instanceDataArray = newStr\n    .replaceAll(\"\\n\", \"\")\n    .replaceAll(\"\\r\", \"\")\n    .replaceAll(\"\\t\", \"\")\n    .replaceAll('[\"', '\"')\n    .replaceAll('\"]', '\"')\n    .replaceAll(\" = \", \":\")\n    .replaceAll(\",}\", \"}\")\n    .split(enumRegexp);\n\n  // Parse all valid objects\n  let parsedData: ArenaMatch[] = [];\n  instanceDataArray.forEach((el, idx) => {\n    try {\n      parsedData.push(JSON.parse(el));\n    } catch (e) {\n      // Ignore failed parses (random strings and AB instances)\n      // console.log(e);\n    }\n  });\n  return parsedData;\n};\n","import { ColorRangeInfo } from \"../Types/ArenaTypes\";\n\nfunction calculatePoint(\n  index: number,\n  intervalSize: number,\n  colorRangeInfo: ColorRangeInfo\n) {\n  const { colorStart, colorEnd, useEndAsStart } = colorRangeInfo;\n  return useEndAsStart\n    ? colorEnd - index * intervalSize\n    : colorStart + index * intervalSize;\n}\n\nexport default function generateChartColors(\n  dataLength: number,\n  colorScale: (i: number) => string,\n  colorRangeInfo: ColorRangeInfo,\n  targetArray: string[]\n) {\n  const { colorStart, colorEnd } = colorRangeInfo;\n  const colorRange = colorEnd - colorStart;\n  const intervalSize = colorRange / dataLength;\n  let i, colorPoint;\n\n  for (i = 0; i < dataLength; i++) {\n    colorPoint = calculatePoint(i, intervalSize, colorRangeInfo);\n    targetArray.push(colorScale(colorPoint));\n  }\n}\n\nexport {};\n","import React from \"react\";\nimport { Bar } from \"react-chartjs-2\";\nimport { interpolateTurbo } from \"d3-scale-chromatic\";\nimport {\n  ChartDataSet,\n  ColorRangeInfo,\n  SortableTeamCompObj,\n  TeamCompDataset,\n} from \"../Types/ArenaTypes\";\nimport generateChartColors from \"../utils/colorGeneration\";\n\ntype BarChartProps = {\n  dataset: TeamCompDataset;\n};\n\nfunction calcWinrate(matchCount: number, wins: number): string {\n  return ((wins / matchCount) * 100).toFixed(1);\n}\n\nconst BarChart: React.FC<BarChartProps> = ({ dataset }) => {\n  const colorRangeInfo: ColorRangeInfo = {\n    colorStart: 0.1,\n    colorEnd: 0.85,\n    useEndAsStart: true,\n  };\n  let totalMatchNumber = 0;\n  let totalWins = 0;\n  let totalLosses: number;\n  let totalWinrate: string;\n  const labelArr: (string | string[])[] = [];\n  const dataArr: number[] = [];\n  const winsArr: number[] = [];\n  let colorArray: string[] = [];\n  const options: any = {\n    indexAxis: \"y\",\n    responsive: true,\n    scales: {\n      y: {\n        ticks: {\n          color: \"#292F36\",\n          font: { size: 15, family: \"'Roboto', sans-serif\" },\n          stepSize: 1,\n          beginAtZero: true,\n        },\n      },\n    },\n    plugins: {\n      tooltip: {\n        callbacks: {\n          afterLabel: (tooltip: any) => {\n            const index = tooltip.dataIndex;\n            const wins = tooltip.dataset.wins[index];\n            const matchCount = tooltip.dataset.data[index];\n            const winrate: string = calcWinrate(matchCount, wins);\n            return [\n              `Wins: ${wins}, Losses: ${matchCount - wins}`,\n              `WR: ${winrate}%`,\n            ];\n          },\n        },\n      },\n      legend: {\n        display: false,\n      },\n    },\n  };\n  const data: ChartDataSet = {\n    labels: labelArr,\n    datasets: [\n      {\n        label: \"\",\n        data: dataArr,\n        wins: winsArr,\n        backgroundColor: colorArray,\n        borderColor: [],\n        borderWidth: 1,\n        hoverOffset: 6,\n      },\n    ],\n  };\n\n  const datasetKeys = Object.getOwnPropertyNames(dataset);\n  const sortableEntries: SortableTeamCompObj[] = [];\n  datasetKeys.forEach((key) => {\n    const { matchCount, wins } = dataset[key];\n    sortableEntries.push({ teamComp: key, matchCount, wins });\n  });\n  sortableEntries.sort((a, b) => b.matchCount - a.matchCount);\n  sortableEntries.forEach((entry) => {\n    const { matchCount, wins, teamComp } = entry;\n    totalMatchNumber += matchCount;\n    totalWins += wins;\n    labelArr.push([teamComp]);\n    dataArr.push(matchCount);\n    winsArr.push(wins);\n  });\n  generateChartColors(\n    sortableEntries.length,\n    interpolateTurbo,\n    colorRangeInfo,\n    colorArray\n  );\n  totalLosses = totalMatchNumber - totalWins;\n  totalWinrate = calcWinrate(totalMatchNumber, totalWins);\n  const chartTitle: string = `Matches Played: ${totalMatchNumber}, Wins: ${totalWins}, Losses: ${totalLosses}, WR: ${totalWinrate}%,`;\n\n  return (\n    <>\n      <div className=\"header\">\n        <h1 className=\"title\">{chartTitle}</h1>\n      </div>\n      <Bar data={data} options={options} />\n    </>\n  );\n};\n\nexport default BarChart;\n","import { ArenaMatch, MatchSessions } from \"../Types/ArenaTypes\";\nimport dayjs from \"dayjs\";\nimport isBetween from \"dayjs/plugin/isBetween\";\ndayjs.extend(isBetween);\n\nexport function getSessions(matches: ArenaMatch[]): MatchSessions {\n  const matchSessions: MatchSessions = {};\n  matches.sort((a, b) => a.enteredTime - b.enteredTime);\n\n  let sessionKey: number | null = null;\n  let prevMatch: ArenaMatch;\n  matches.every((match) => {\n    if (sessionKey) {\n      // If session object is present, find if new match fits that session time frame\n      const prevMatchEnterTime = dayjs.unix(prevMatch.enteredTime);\n      const matchIsWithinOldSession = dayjs\n        .unix(match.enteredTime)\n        .isBetween(prevMatchEnterTime, prevMatchEnterTime.add(1, \"hour\"));\n\n      // If match fits, add it to old session\n      if (matchIsWithinOldSession) {\n        matchSessions[sessionKey].push(match);\n        prevMatch = match;\n        return true;\n      }\n    }\n\n    // If match doesn't fit or session key is null, create new session\n    sessionKey = match.enteredTime;\n    prevMatch = match;\n    matchSessions[sessionKey] = [match];\n    return true;\n  });\n\n  return matchSessions;\n}\n","import React, { useRef, useState } from \"react\";\nimport { MatchSessions, SessionSelectOption } from \"../Types/ArenaTypes\";\nimport Select, { ActionMeta, MultiValue } from \"react-select\";\nimport dayjs from \"dayjs\";\n\nexport type sessionSelectProps = {\n  sessionData: MatchSessions;\n  onChange: (value: number[]) => void;\n};\n\nconst SessionSelect: React.FC<sessionSelectProps> = ({\n  sessionData,\n  onChange,\n}) => {\n  const [selected, setSelected] = useState<MultiValue<SessionSelectOption>>([]);\n  const valueRef = useRef(selected);\n  valueRef.current = selected;\n\n  const sessionKeys: string[] = Object.getOwnPropertyNames(sessionData);\n  const selectAllOption: SessionSelectOption = {\n    value: 0,\n    label: \"All Data\",\n  };\n  const options: SessionSelectOption[] = [];\n  sessionKeys.forEach((key, idx) => {\n    const timestamp: number = Number(key);\n    const formattedData: string = dayjs\n      .unix(timestamp)\n      .format(\"HH:mm - DD/MM/YY\");\n    const sessionOption = {\n      value: timestamp,\n      label: `Session ${idx + 1}, @ ${formattedData}`,\n    };\n    options.push(sessionOption);\n  });\n  options.reverse();\n\n  const isSelectAllSelected = () =>\n    valueRef?.current?.length === options.length;\n\n  const getOptions = () => [selectAllOption, ...options];\n\n  const isOptionSelected = (option: SessionSelectOption): boolean =>\n    valueRef?.current?.some(({ value }) => value === option.value) ||\n    isSelectAllSelected();\n\n  const getValue = () => (isSelectAllSelected() ? [selectAllOption] : selected);\n\n  const handleChange = (\n    newValue: MultiValue<SessionSelectOption>,\n    actionMeta: ActionMeta<SessionSelectOption>\n  ) => {\n    const selectedTimestampArray: number[] = [];\n    const { action, option, removedValue } = actionMeta;\n    if (action === \"select-option\" && option?.value === selectAllOption.value) {\n      setSelected(options);\n      selectedTimestampArray.push(...options.map((option) => option.value));\n    } else if (\n      (action === \"deselect-option\" &&\n        option?.value === selectAllOption.value) ||\n      (action === \"remove-value\" &&\n        removedValue?.value === selectAllOption.value)\n    ) {\n      setSelected([]);\n    } else if (\n      actionMeta.action === \"deselect-option\" &&\n      isSelectAllSelected()\n    ) {\n      const filteredOptions = options.filter(\n        ({ value }) => value !== option?.value\n      );\n      setSelected(filteredOptions);\n      selectedTimestampArray.push(\n        ...filteredOptions.map((option) => option.value)\n      );\n    } else {\n      setSelected(newValue || []);\n      selectedTimestampArray.push(...newValue.map((option) => option.value));\n    }\n    onChange && onChange(selectedTimestampArray);\n  };\n\n  return (\n    <Select\n      className={\"session-select\"}\n      classNamePrefix={\"session-select\"}\n      defaultValue={selectAllOption}\n      isOptionSelected={isOptionSelected}\n      options={getOptions()}\n      value={getValue()}\n      onChange={handleChange}\n      hideSelectedOptions={false}\n      closeMenuOnSelect={false}\n      isMulti\n    />\n  );\n};\n\nexport default SessionSelect;\n","import React, { useEffect, useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport UploadArea from \"./UploadArea\";\nimport {\n  INSTANCE_DATA,\n  localStorageToState,\n  MY_CHAR_NAME,\n  setLocalStorageField,\n} from \"../utils/stateManagement\";\nimport {\n  ArenaMatch,\n  CharnameFormData,\n  MatchSessions,\n  ModdedArenaMatch,\n  TeamCompDataset,\n} from \"../Types/ArenaTypes\";\nimport BarChart from \"./BarChart\";\nimport {\n  createBasicChartDataset,\n  filterArenaMatches,\n} from \"../utils/dataSetHelpers\";\nimport { getSessions } from \"../utils/dateManagement\";\nimport SessionSelect from \"./SessionSelect\";\n\nexport type dashboardProps = {\n  className?: string;\n};\n\nconst Dashboard: React.FC<dashboardProps> = () => {\n  const { register, handleSubmit } = useForm();\n  const [myCharName, setMyCharName] = useState<string>(\"\");\n  const [matchData, setMatchData] = useState<ModdedArenaMatch[]>([]);\n  const [sessionData, setSessionData] = useState<MatchSessions>({});\n  const [sessionSelection, setSessionSelection] = useState<number[]>([0]);\n  const [localStorageChanged, setLocalStorageChanged] =\n    useState<boolean>(false);\n  const [chartDataset, setChartDataset] = useState<TeamCompDataset>({});\n\n  useEffect(() => {\n    localStorageToState(MY_CHAR_NAME, setMyCharName);\n  }, []);\n  useEffect(() => {\n    const lsMatchState = window.localStorage.getItem(INSTANCE_DATA);\n    const lsCharNameState = window.localStorage.getItem(MY_CHAR_NAME);\n    const stateIsPresent = lsMatchState && lsCharNameState;\n    if (stateIsPresent) {\n      const parsedMatchData = JSON.parse(lsMatchState);\n      const parsedCharData = JSON.parse(lsCharNameState);\n      stateIsPresent && setSessionData(getSessions(parsedMatchData));\n      if (sessionSelection.includes(0)) {\n        setMatchData(filterArenaMatches(parsedMatchData, parsedCharData, true));\n      } else {\n        const selectedMatches: ArenaMatch[] = [];\n        sessionSelection.forEach((sessionKey) => {\n          selectedMatches.push(...sessionData[sessionKey]);\n        });\n        setMatchData(filterArenaMatches(selectedMatches, parsedCharData, true));\n      }\n    }\n  }, [localStorageChanged, sessionSelection]);\n  useEffect(\n    () => setChartDataset(createBasicChartDataset(matchData)), // create dataset\n    [matchData]\n  );\n\n  const onSubmit = (data: CharnameFormData) => {\n    setLocalStorageField(MY_CHAR_NAME, data.charName);\n    setLocalStorageChanged(!localStorageChanged);\n  };\n\n  return (\n    <div className=\"dashboard\">\n      <div className=\"dashboard__top-bar\">\n        <UploadArea\n          localStoreChangeHandler={setLocalStorageChanged}\n          localStorageChangeValue={localStorageChanged}\n        />\n        <div className=\"dashboard__filters\">\n          <form onSubmit={handleSubmit(onSubmit)}>\n            <input\n              className=\"dashboard__charname-input\"\n              {...register(\"charName\")}\n              placeholder={`${myCharName}`}\n            />\n            <button className=\"dashboard__submit-charname\" type=\"submit\">\n              Submit\n            </button>\n          </form>\n          {sessionData && (\n            <SessionSelect\n              onChange={setSessionSelection}\n              sessionData={sessionData}\n            />\n          )}\n        </div>\n      </div>\n      {matchData && (\n        <div className=\"dashboard__chart-container\">\n          <BarChart dataset={chartDataset} />\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Dashboard;\n","import React from \"react\";\nimport \"./App.css\";\nimport Dashboard from \"./components/Dashboard\";\n\nfunction App() {\n  return (\n    <div className=\"main-wrap\">\n      <Dashboard />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"normalize.css\";\nimport \"./styles/index.scss\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}